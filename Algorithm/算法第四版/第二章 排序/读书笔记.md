# 第二章 排序

## 2.1 初级排序算法

1. 在研究排序算法时,需要计算比较和交换的数量

   对于不交换元素的算法,需要计算访问数组的次数.

2. 排序算法可以分为两类:

   无需额外内存的原地排序算法,以及需要额外内存的其他排序算法

3. **选择排序**

    找到数组中最小的元素,将他和数组的第一个元素交换位置.然后在剩下的元素中,找到最小的元素,将它与数组的第二个元素交换位置.如此往复.

    特点1:运行时间与输入无关.这是一个不好的特性.任何性质的输入都不能帮助改进算法的性能.

    特点2:数据移动次数少.只用了N次.

    适用于:没啥适用的.

4. **插入排序**

    索引左侧的元素全部都是有序的.索引不断向右移动,当移动到最右端,整个数组有序.

    特点:对于基本有序的数组,插入排序的效率很高.数组的初始有序性越高,插入排序的效率越高,甚至可以达到所有排序算法中最高的.

    适用于:部分有序数组以及小规模数组.

5. 比较排序算法

    编写"比较"程序,通过测试不同算法的耗时程度,来比较算法的性能.

6. **希尔排序**

    存在一个递增序列[1,3,13,40,...],利用递增序列内的数,进行插入排序.

    特点:简单,易于实现,且性能不错.

    适用于:没有系统排序函数的情况.(少见)
___

## 2.2 归并排序

归并操作:将两个有序的小数组归并为一个大的有序数组.

归并排序是一种递归归并的排序算法.

> 长度为n的数组排序所需时间和$NlogN$成正比。
>
> 所需的额外空间和$N$成正比。

一种朴素的归并方式是采用第三个数组进行归并。但这样是不好的，因为每次归并都会创建一个新的数组。

因此，最好的方式是采用原地归并。——原地归并方法。

### 自顶向下的归并方法

基于分治思想：

如果他能将两个子数组排序，就能通过归并两个子数组来给整个数组排序。

### 自底向上的归并方法

先进行两两归并，然后进行四四归并，以此类推。

适合用链表组织的数据。

### 排序算法的复杂度

先鸽了。

___

## 2.3 快速排序

### 基本算法

同样基于分治思想。将一个数组分成两个子数组，两部分分别进行独立排序。

当两个子数组都有序时，整个数组就有序了。

首先对待排序的数组进行打乱，消除随机性。

然后进行切分，将a[j]放在合适的位置，a[j]左数组均比其小，右数组均比其大。然后递归执行切分步骤。

切分方法：

设待切分的数组为a，其第一个元素为a[lo].

* 选取a[lo]作为切分元素。从数组左端向右扫描，找到一个比a[lo]大的元素。
* 从数组右端向左扫描，找到一个比a[lo]小的元素。
* 交换刚才找到的两个元素的位置。
* 不断重复扫描过程，直到扫描指针相遇。
* 将相遇的指针对应的元素与a[lo]交换位置，a[lo]就被安排在了正确的位置上。

### 性能特点

鸽了。在看完性能分析之后统一分析。

## 算法改进

### 切换到插入排序

对于小数组（一般来说为元素数目小于15的子数组），可以切换到插入排序来提升速度。

### 三向切分

当待排序数组存在大量重复元素时，可以采用三向切分的方法提升排序速度。

三向切分的快速排序程序是排序库函数的最佳选择。

## 2.4 优先队列

一种抽象数据类型，支持两种操作：

* 删除最大元素
* 插入元素

优先队列结构适合处理『$N$个输入中找到最大的前$M$个元素』这种问题；尤其是在$N$的**数量特别大**以至于无法将其进行完全排序的情况。

优先队列有两种实现方式。

### 初级实现方式

初级实现方式可以利用有序数组、无序数组或者链表的方式进行实现。

设问题为：『$N$个输入中找到最大的前$M$个元素』

从输入中读取元素，并将其置入到优先队列当中；当队列的长度大于$M$，删除队列中最小的元素。

### 基于堆实现的方式

数据结构**二叉堆**能够很好的实现优先队列结构。

#### 堆的定义

将所有元素画成一棵二叉树：

> 当一棵二叉树的每个节点都大于等于他的两个子节点时，他被称为**堆有序**。

可以看出，根节点是堆有序二叉树中最大的节点。

> 二叉堆（简称为堆）是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存。
>
> 二叉堆不使用数组的第一个位置。

在一个堆中，节点$K$的父节点位置为$\lfloor k/2 \rfloor$,子节点的位置为$2k$和$2k+1$

#### 堆的算法

使用长度为$N+1$的数组来表示一个大小为$N$的堆。

堆的有序化是一个重要的步骤。有序化的过程中，可能会遇到两种情况：

* 某个节点的优先级上升（或新增加一个元素），此时需要由下而上的恢复堆的顺序（上浮）。
* 某个节点的优先级下降（比如替换根节点），此时需要由上而下的回复堆的顺序（下沉）。

##### 上浮（$swim$）

如果某个节点因为变的比他的父节点更大而导致堆无序，则需要通过交换他和他的父节点来修复堆。

但是这个节点仍然可能比他现在大父节点更大，所以需要一遍遍的同样方法来修复堆。

##### 下沉（$sink$）

如果某个节点变得比他两个子节点之一更小导致堆无序，则将其与其两个子节点中较大的一个进行交换。

同样的，这个操作需要进行多次，来确保堆已经被修复。

#### 基于堆的优先队列

* 优先队列由一个基于堆的完全二叉树表示，储存在数组$pq[1..N]$中（$pq[0]$不被使用）。

* 插入新元素时，将$N=N+1$，将新元素添加在数组最后，然后用$swim()$恢复秩序；

* 删除最大元素时，取$pq[1]$为返回值，然后将$pq[N]$移动到$pq[1]$，将$N=N-1$,然后用$sink()$恢复对的秩序。然后将$pq[N+1]$设为NULL用于释放内存。

### 堆排序